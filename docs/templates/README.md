# ğŸ§© Code Templates

This directory contains Jinja2 templates for generating code based on the specifications defined in `docs/codex/`. These templates provide reusable code patterns that can be applied to any project following the codex standards.

## ğŸ“ Template Categories

### ğŸ¨ Components (`components/`)
UI component templates for frontend applications:
- **input_dropdown_select.py.j2** - Dropdown selection component
- **input_validated_input.py.j2** - Validated input field component

### âš™ï¸ Configs (`configs/`)
Configuration file templates:
- **config_logging.json.j2** - Logging configuration template
- **config_template.json.j2** - General configuration template

### ğŸ“ Docs (`docs/`)
Documentation templates:
- **template.openapi_schema.md.j2** - OpenAPI schema documentation

### ğŸ› ï¸ Helpers (`helpers/`)
Helper utility templates:
- **helper_config_loader.py.j2** - Configuration loader utility

### ğŸ“Š Logger (`logger/`)
Logging system templates:
- **logger_template.py.j2** - Logger initialization template

### ğŸ—ï¸ Models (`models/`)
Data model templates:
- **model_base.py.j2** - Base model template
- **model_pydantic_v2.py.j2** - Pydantic v2 model template

### ğŸ›£ï¸ Routers (`routers/`)
Route definition templates:
- **route_template_fastapi.py.j2** - FastAPI route template
- **route_template_nicegui.py.j2** - NiceGUI route template

### ğŸ”§ Utils (`utils/`)
Utility function templates:
- **utility_template.py.j2** - General utility function template

### âœ… Validators (`validators/`)
Input validation templates:
- **validator_template.py.j2** - Input validation template

### ğŸ“„ Templates (`templates/`)
General file templates:
- **template.api_router.py** - API router template
- **template.config_loader.py** - Configuration loader template
- **template.error_model.py** - Error model template
- **template.gitignore** - Git ignore template
- **template.mkdocs.yml** - MkDocs configuration template
- **template.response_model.py** - Response model template
- **template.service_logic.py** - Service logic template
- **template.test_api_success.py** - API test template

## ğŸš€ How to Use Templates

### 1. **Understand the Specification**
Before using a template, review the corresponding specification in `docs/codex/`:
```bash
# Example: For FastAPI routes
cat docs/codex/spec.backend.fastapi.structure.md
```

### 2. **Choose the Right Template**
Select the template that matches your needs:
```bash
# Example: For creating a new FastAPI route
cat docs/templates/routers/route_template_fastapi.py.j2
```

### 3. **Customize the Template**
Modify the template with your specific requirements:
```bash
# Example: Generate a custom route
jinja2 docs/templates/routers/route_template_fastapi.py.j2 \
  -D resource=users \
  -D version=v1 \
  > app/routes/users.py
```

### 4. **Follow the Pattern**
Use the generated code as a starting point and follow the patterns established in the specification.

## ğŸ“‹ Template Variables

Each template uses Jinja2 variables that you can customize:

### Common Variables
- `{{ app_name }}` - Application name
- `{{ version }}` - API version
- `{{ resource }}` - Resource name
- `{{ class_name }}` - Class name
- `{{ function_name }}` - Function name

### Component-Specific Variables
- `{{ name }}` - Field name
- `{{ label }}` - Display label
- `{{ validation_rules }}` - Validation rules
- `{{ placeholder }}` - Input placeholder

### Configuration Variables
- `{{ log_level }}` - Logging level
- `{{ log_file }}` - Log file path
- `{{ config_path }}` - Configuration file path

## ğŸ”— Template-Specification Mapping

Each template corresponds to one or more specifications:

| Template | Specification | Purpose |
|----------|---------------|---------|
| `route_template_fastapi.py.j2` | `spec.backend.fastapi.structure.md` | FastAPI route generation |
| `input_validated_input.py.j2` | `spec.ui.nicegui.md` | NiceGUI input component |
| `logger_template.py.j2` | `spec.infrastructure.logging.md` | Logging setup |
| `model_pydantic_v2.py.j2` | `spec.project.structure.md` | Data model generation |

## ğŸ› ï¸ Template Development

### Creating New Templates

1. **Follow Naming Convention:**
   ```
   template_name.py.j2
   ```

2. **Include Proper Documentation:**
   ```jinja2
   # File: {{ app_name }}/{{ file_path }}
   # AUTO-GENERATED BY CODEX
   # Template: {{ template_name }}
   # Purpose: {{ template_purpose }}
   ```

3. **Use Descriptive Variables:**
   ```jinja2
   class {{ class_name }}:
       """{{ class_description }}"""
   ```

4. **Include Usage Examples:**
   ```jinja2
   # Usage:
   # jinja2 {{ template_name }} -D class_name=MyClass -D description="My description"
   ```

### Template Best Practices

1. **Keep Templates Focused:** Each template should serve a single, clear purpose
2. **Use Descriptive Variables:** Variable names should be self-explanatory
3. **Include Documentation:** Add comments explaining the template's purpose
4. **Follow Code Standards:** Generated code should follow the quality specifications
5. **Test Templates:** Verify that generated code works correctly

## ğŸ“Š Validation

Templates are validated against specifications:

```bash
# Run template validation
make validate-codex

# This checks:
# - Template syntax correctness
# - Template-specification references
# - Variable consistency
# - Generated code quality
```

## ğŸ”— Related Documentation

- **[Codex Specifications](../codex/README.md)** - Template specifications
- **[Project Examples](../projects/)** - Example implementations
- **[Quality Standards](../codex/spec.quality.code.md)** - Code quality guidelines

## ğŸ¯ Benefits

Using these templates provides:

- **â™»ï¸ Consistency:** Standardized code patterns across projects
- **âš¡ Speed:** Rapid code generation for common patterns
- **ğŸ” Quality:** Pre-validated code that follows best practices
- **ğŸ“š Maintainability:** Centralized templates that can be updated
- **ğŸ¯ Focus:** Developers can focus on business logic rather than boilerplate

The templates are designed to work together with the codex specifications to provide a complete development framework for Python applications.
